{
    "description": "<p>Test of complex number handling.&nbsp; Note that the HP42S commands <code>COMPLEX</code>, <code>toPOL</code> and <code>toREC</code> can take either one or two parameters - and return either one or two parameters. See HP42S RPN reference page on this website or study this example for details.</p>\r\n<p>The Python way of entering complex numbers is also supported viz.&nbsp;<span style=\"color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\">You can also enter complex numbers without this COMPLEX function using native Python syntax e.g.&nbsp;</span><code style=\"box-sizing: border-box; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12.6px; padding: 2px 4px; color: #c7254e; white-space: nowrap; background-color: #f9f2f4; border-radius: 4px;\">0 + 1j</code><span style=\"color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\">&nbsp;which is engineering notation for&nbsp;</span><code style=\"box-sizing: border-box; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12.6px; padding: 2px 4px; color: #c7254e; white-space: nowrap; background-color: #f9f2f4; border-radius: 4px;\">0 + i1</code><span style=\"color: #333333; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;\">. Yes, Python uses the letter 'j' not the letter 'i' and puts it after the imaginary number, not before.</span></p>",
    "public": "yes",
    "sortnum": 5,
    "source": "def complex_play():\r\n  RAD()  # Set angular mode\r\n  RECT() # Set coordinate mode\r\n  FIX(3) # For effective comparisons, need to round down with RND\r\n         # Arbitrarily set here so that RND will adhere to 3 decimal places\r\n\r\n  # Use native Python syntax for entering complex numbers\r\n  c = (5 + 3j) + (7 - 9j)\r\n  assert c == (12 - 6j)\r\n  assert isCPX(c)\r\n\r\n  # Use HP42 way of entering complex numbers\r\n  c = COMPLEX(5, 3) + COMPLEX(7, -9)\r\n  assert c == (12 - 6j)\r\n  assert isCPX(c)\r\n\r\n  # Break a complex number into its parts\r\n  real, imag = COMPLEX(c)\r\n  assert real == 12\r\n  assert IP(imag) == -6\r\n  \r\n  # Convert a complex number from RAD to POL  \r\n  cpol = toPOL(c)\r\n  # check result\r\n  real, imag = COMPLEX(cpol)\r\n  assert RND(real) == 13.416\r\n  assert RND(imag) == -0.464\r\n  # another way of checking the result\r\n  assert RND(cpol) == RND(COMPLEX(13.416, -0.464))\r\n  # or more pythonically\r\n  assert RND(cpol) == RND(13.416 - 0.464j)\r\n  \r\n  # Convert the complex number back to RAD angular mode\r\n  c = toREC(cpol)\r\n  real, imag = COMPLEX(c)\r\n  assert real == 12\r\n  assert IP(imag) == -6\r\n\r\n  # Some operations result in a complex number\r\n  # If you suspect this might happen, use the 'rpn: named' directive\r\n  # so that the resulting complex number gets assigned to a named variable\r\n  # and not the default, which is a numbered register.  Tricky!\r\n  csq = SQRT(-25)  # rpn: named\r\n  real, imag = COMPLEX(csq)\r\n  # check result which should be 0 + i5\r\n  assert real == 0\r\n  assert IP(imag) == 5\r\n  # check again\r\n  assert RND(csq) == RND(0 + 5j)\r\n  # check again\r\n  assert RND(csq) == RND(COMPLEX(0, 5))\r\n  # to polar and check again\r\n  cpol = toPOL(csq)\r\n  assert RND(cpol) == RND(COMPLEX(5, 1.571))\r\n  assert RND(cpol) == RND(5 + 1.571j)\r\n\r\n  # To polar can also take two parameters. \r\n  # Converts x and y to the corresponding polar coordinates r and \u03b8.\r\n  a, b = toPOL(1, 2)\r\n  assert RND(a) == 0.464\r\n  assert RND(b) == 2.236\r\n  # To rect can also take two parameters. \r\n  a, b = toREC(1, 2)\r\n  assert RND(a) == 1.683\r\n  assert RND(b) == 1.081\r\n\r\n  print('complex tests pass ok')",
    "tags": "Complex_Numbers",
    "title": "Complex test"
}