{
    "description": "<p>The \"programmable menu\" feature of the HP42S lets you create your own menu - pressing the key underneath each menu item will execute the associated function.&nbsp; There is both a traditional and new simplified way of building these menus.</p>\r\n<p>The new simplified <code>menu()</code> function takes a list of string menu items - representing the function names you want to call.&nbsp; The assigning to keys and all other wiring will be done automatically.</p>\r\n<p>You must of course define the user functions being called, which by default will be converted into local labels beginning with A, and thus won't pollute the global namespace.&nbsp; If you want one of your called functions to be a named label, then as usual, use the comment directive <code>rpn: export</code>&nbsp;on the function definition 'def' line.</p>\r\n<p>If you want to pass parameters to your functions then key them in onto the stack before pressing the menu button.&nbsp; For example to satisfy the call to <code>add(a, b)</code> type <code>10 ENTER 20</code> before pressing the menu button for add.&nbsp; The number 10 will arrive as the parameter 'a' and 20 will arrive as the parameter 'b'.</p>\r\n<p><strong><span style=\"text-decoration: underline;\">Traditional MENU technique</span></strong></p>\r\n<p>If you want to build HP42S the traditional way you can do so thus:</p>\r\n<pre class=\"language-python\"><code>def ui1_traditional():  # traditional technique\r\n  CLMENU()\r\n  \"Do A\"\r\n  KEYG(1, \"do_a\")\r\n  \"B\"\r\n  KEYG(2, \"do_b\")\r\n  MENU()\r\n\r\ndef do_a():  # this will turn into local label A\r\n  print('you chose blah1')\r\n\r\ndef do_b():  # this will be a named label - rpn: export\r\n  print('you chose blah2')</code></pre>\r\n<p>The traditional approach is more laborious, but gives you the advantage of being able to call the menu items something different than the name of the function e.g. notice above that the menu item \"Do A\" calls the function do_a.</p>\r\n<p>With the traditional approach&nbsp;you may need to clear the menu before you build it - because old MENU definitions hang around till explicitly cleared.&nbsp; The simplified <code>menu()</code> automatically does a&nbsp;<code>CLMENU</code>&nbsp;for you.</p>\r\n<p>Finally, the simplified&nbsp;menu()&nbsp;command implements&nbsp;<code>KEYG</code> semantics, which means each key will run the specified function - this is the behaviour most people expect.&nbsp; If you actually want the KEYX semantics of XEQ then you will need to build the menu in the traditional way, where you get more control and can specify either KEYG or KEYX. P.S. If anybody can point out uses of KEYX, please let me know - <em>I find it most confusing!</em></p>",
    "public": "yes",
    "sortnum": 5,
    "source": "def ui1():\r\n  menu(\"hello\", \"func2\", \"add\")  # new easy menu technique\r\n\r\ndef hello():\r\n  print('you chose hello')\r\n\r\ndef func2():\r\n  print('you chose func2')\r\n  return 50\r\n\r\ndef add(a, b):\r\n  return a + b",
    "tags": "User_Interface",
    "title": "Menu"
}