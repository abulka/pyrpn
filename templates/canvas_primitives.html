{% extends "base.html" %}
{% block additional_js %}
<!--<link rel="stylesheet" href="../static/js/lib/prism.css">-->
<!--<script src="../static/js/lib/prism.js"></script>-->
{% endblock %}

{% block content %}
<ul>
    <li><a href="/">Converter</a></li>
    <li><a href="/examples">Examples</a></li>
    <li><a href="/help">Help</a></li>
    <li><a href="/subscribe">Subscribe to new feature announcements</a></li>
</ul>

<div class="andy_content">

    <p>
        The drawings below were generated by graphic primitive functions that ultimately
        use a single <b>PIXEL</b> function,
        like the one the HP42S has.
    </p>
    <p>
        The graphic drawing functions:</p>
    <ul>
        <li><b>draw_line</b>(x0, y0, x1, y1)</li>
        <li><b>draw_rect</b>(x0, y0, w, h)</li>
        <li><b>fill_rect</b>(x0, y0, w, h)</li>
        <li><b>draw_circle</b>(x0, y0, r)</li>
        <li><b>fill_circle</b>(x0, y0, r)</li>
    </ul>
    <p>
        have been written in Python and then auto-converted to RPN, using the Python to RPN <a href="/">Converter</a>.
    </p>
    <p>
        These demos and underlying graphic drawing primitive functions
        will therefore <i>run on your calculator</i>.   At least, its been tested in Free42.
        See the <a href="/examples">Examples</a> section for the full code.
    </p>


    <h1>HP42S / Free42</h1>
    <canvas id="myCanvas0" width="131" height="16" style="border:1px solid #000000; border-color: red;"></canvas>
    <canvas id="myCanvas1" width="131" height="16" style="border:1px solid #000000; border-color: red;"></canvas>
    <canvas id="myCanvas2" width="131" height="16" style="border:1px solid #000000; border-color: red;"></canvas>
    <p>(131 x 16)</p>

    <h1>DM42</h1>
    <canvas id="myCanvas10" width="200" height="120" style="border:1px solid #000000; border-color: red;"></canvas>
    <canvas id="myCanvas11" width="200" height="120" style="border:1px solid #000000; border-color: red;"></canvas>
    <p>(200 x 120)</p>
    <canvas id="myCanvas20" width="400" height="240" style="border:1px solid #000000; border-color: red;"></canvas>
    <p>(400 x 240)</p>

    <p>
        This simulation is in javascript, which is why you can view it in your browser.
        Thanks to <a
            href="http://raspberrycompote.blogspot.com.au/2014/04/low-level-graphics-on-raspberry-pi-text.html">
        this article</a> which provided the basis of these algorithms.
    </p>
</div>

<script>
    // JavaScript for drawing on canvas only with pixels
    // Based on http://raspberrycompote.blogspot.com.au/2014/04/low-level-graphics-on-raspberry-pi.html

    let ctx
    let vinfo = {xres: 131, yres: 16}
    // let vinfo = {xres:200, yres:120}
    // let vinfo = {xres:400, yres:240}

    function setup(canvas_id) {
        var canvas = document.getElementById(canvas_id);
        if (canvas.getContext) {
            ctx = canvas.getContext('2d');
        }
        vinfo = {xres: canvas.width, yres: canvas.height}
        console.log('canvas switched', vinfo)
    }

    function pixel(x, y) {
        // HP42S is 1 based so need to subtract 1
        x -= 1
        y -= 1
        ctx.fillRect(x, y, 1, 1);
    }

    function draw_line(x0, y0, x1, y1) {
        // console.log('draw_line', x0, y0, x1, y1)
        x0 = Math.trunc(x0)
        y0 = Math.trunc(y0)
        x1 = Math.trunc(x1)
        y1 = Math.trunc(y1)
        let dx = Math.abs(x1 - x0)
        let dy = Math.abs(y1 - y0)
        let sx;
        let sy;
        if (x0 < x1)
            sx = 1;
        else
            sx = -1;
        if (y0 < y1)
            sy = 1;
        else
            sy = -1;
        let err = dx - dy
        let e2;
        let done = 0;
        let failsafe = 2000;
        while (!done) {
            failsafe -= 1
            // console.log('x0=', x0, 'y0=', y0, 'x1=', x1, 'y1=', y1, 'err=', err, 'e2', e2, 'done?', (x0 == x1) && (y0 == y1), )
            if (failsafe < 0) {
                console.error('failsafe kicked in')
                break
            }

            pixel(x0, y0);
            if ((x0 == x1) && (y0 == y1))
                done = 1;
            else {
                e2 = 2 * err
                if (e2 > -dy) {
                    err = err - dy
                    x0 = x0 + sx
                }
                if (e2 < dx) {
                    err = err + dx
                    y0 = y0 + sy
                }
            }
        }
    }

    // (x0, y0) = left top corner coordinates
    // w = width and h = height
    function draw_rect(x0, y0, w, h) {
        //console.log('draw_rect', x0, y0, w, h);
        draw_line(x0, y0, x0 + w, y0); // top
        draw_line(x0, y0, x0, y0 + h); // left
        draw_line(x0, y0 + h, x0 + w, y0 + h); // bottom
        draw_line(x0 + w, y0, x0 + w, y0 + h); // right
    }


    function fill_rect(x0, y0, w, h) {
        for (let y = 0; y < h; y++) {
            draw_line(x0, y0 + y, x0 + w, y0 + y);
        }
    }


    function draw_circle(x0, y0, r) {
        x0 = Math.trunc(x0)
        y0 = Math.trunc(y0)
        r = Math.trunc(r)
        x = r;
        y = 0;
        radiusError = 1 - x;

        while (x >= y) {
            //console.log('x= ', x, ' y= ', y, ' ', radiusError, ' ', x >= y)
            // top left
            pixel(-y + x0, -x + y0);
            // top right
            pixel(y + x0, -x + y0);
            // upper middle left
            pixel(-x + x0, -y + y0);
            // upper middle right
            pixel(x + x0, -y + y0);
            // lower middle left
            pixel(-x + x0, y + y0);
            // lower middle right
            pixel(x + x0, y + y0);
            // bottom left
            pixel(-y + x0, x + y0);
            // bottom right
            pixel(y + x0, x + y0);

            y++;
            if (radiusError < 0) {
                radiusError += 2 * y + 1;
            } else {
                x--;
                radiusError += 2 * (y - x + 1);
            }
        }
    }

    function fill_circle(x0, y0, r) {
        x0 = Math.trunc(x0)
        y0 = Math.trunc(y0)
        r = Math.trunc(r)
        let x = r
        let y = 0
        radiusError = 1 - x

        while (x >= y) {
            // top
            draw_line(-y + x0, -x + y0, y + x0, -x + y0);
            // upper middle
            draw_line(-x + x0, -y + y0, x + x0, -y + y0);
            // lower middle
            draw_line(-x + x0, y + y0, x + x0, y + y0);
            // bottom
            draw_line(-y + x0, x + y0, y + x0, x + y0);

            y++;
            if (radiusError < 0) {
                radiusError += 2 * y + 1;
            } else {
                x--;
                radiusError += 2 * (y - x + 1);
            }
        }
    }

    // Now let's play

    function draw() {
        // draw lines
        for (let x = 1; x <= 131; x++)
            pixel(x, 1)
        for (let x = 1; x <= 131; x++)
            pixel(x, 16)

        draw_line(0, 0, 10, 10)
        draw_line(10, 10, 20, 5)
        draw_line(20, 5, 100, 16)
        draw_line(100, 16, 131, 1)

        draw_rect(70, 4, 5, 5)
        fill_rect(18, 9, 12, 4)

        draw_circle(96, 8, 5)
        fill_circle(125, 10, 3)
    }

    function draw3() {
        // draw lines - test whether resilient against floats, which it wasn't previously
        draw_rect(70, 4, 5, 5)
        draw_rect(70, 4, 5.1, 5)
    }

    function draw4() {
        // draw circle debugging
        draw_circle(96, 8, 5)
    }


    function draw2() {
        let x;

        // some pixels
        for (x = 1; x <= vinfo.xres; x += 5)
            pixel(x, vinfo.yres / 2);

        // some lines (note the quite likely 'Moire pattern')
        for (x = 1; x <= vinfo.xres / 4; x += 2) {
            // console.log('Moire', 0, 0, x, vinfo.yres)
            draw_line(0, 0, x, vinfo.yres);
        }


        // some rectangles
        draw_rect(vinfo.xres / 4, vinfo.yres / 2, vinfo.xres / 4, vinfo.yres / 4);
        draw_rect(vinfo.xres / 4 + 10, vinfo.yres / 2 + 4, vinfo.xres / 4 - 20, vinfo.yres / 4);
        fill_rect(vinfo.xres / 8, 1, vinfo.xres / 4, vinfo.yres / 4);

        // some circles
        let d;
        for (d = 2; d < vinfo.yres / 2; d += 2) {
            draw_circle(3 * vinfo.xres / 4, 2 * vinfo.yres / 4, d);  // read as 3/4 across, 2/4 down
        }

        fill_circle(15 * vinfo.xres / 16, 2 * vinfo.yres / 4, vinfo.yres / 3);
        fill_circle(8 * vinfo.xres / 13, 3 * vinfo.yres / 4, vinfo.yres / 2);

    }


    setup('myCanvas0')
    draw()
    setup('myCanvas1')
    draw2()
    setup('myCanvas2')
    draw3()
    draw4()

    setup('myCanvas10')
    draw()
    setup('myCanvas11')
    draw2()

    setup('myCanvas20')
    draw2()


</script>

{% endblock %}